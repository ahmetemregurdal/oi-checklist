generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url = env("DATABASE_PATH")
}

model User {
  id Int @id @default(autoincrement())
  username String @unique
  password String?
  createdAt DateTime @default(now())
  authIdentities AuthIdentity[]
  problemsData UserProblemData[]
  sessions Session[]
  settings Settings?
  virtualContests UserVirtualContest[]
  activeVirtualContest ActiveVirtualContest?
  following Follow[] @relation("UserFollows")
  followers Follow[] @relation("UserFollowedBy")
}

model AuthIdentity {
  id Int @id @default(autoincrement())
  userId Int
  provider String
  providerUserId String?
  displayName String
  createdAt DateTime @default(now())
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([provider, providerUserId])
}

model Problem {
  id Int @id @default(autoincrement())
  name String
  number Int?
  source String?
  year Int?
  extra String
  problemLinks ProblemLink[]
  userProblemsData UserProblemData[]
  contests ContestProblem[]
  @@unique([source, year, number, extra])
  @@unique([name, source, year, extra])
}

model ProblemLink {
  id Int @id @default(autoincrement())
  problemId Int
  platform String
  url String
  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)
  @@unique([problemId, platform, url]) 
}

model UserProblemData {
  userId Int
  problemId Int
  status Int @default(0)
  score Float @default(0)
  note String @default("")
  updatedAt DateTime @default(now())
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)
  @@id([userId, problemId])
}

model Settings {
  userId Int @id
  checklistPublic Boolean @default(false)
  ascSort Boolean @default(false)
  darkMode Boolean @default(false)
  olympiadOrder Json?
  platformPref Json?
  hiddenOlympiads Json?
  platformUsernames Json?
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Session {
  id String @id
  userId Int
  createdAt DateTime @default(now())
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model Contest {
  id Int @id @default(autoincrement())
  name String
  stage String
  location String?
  duration Int?
  source String
  year Int
  date DateTime?
  website String?
  link String?
  note String?
  userContext String?
  contextData Json?
  scores ContestScores?
  problems ContestProblem[]
  userVirtualContests UserVirtualContest[]
  activeVirtualContests ActiveVirtualContest[]
  @@unique([name, stage])
}

model ContestProblem {
  id Int @id @default(autoincrement())
  contestId Int
  problemId Int
  problemIndex Int
  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  problem Problem @relation(fields: [problemId], references: [id], onDelete: Cascade)
  virtualSubmissions VirtualSubmission[]
  @@unique([contestId, problemId])
  @@unique([contestId, problemIndex])
}

model ContestScores {
  contestId Int @id
  medalNames Json?
  medalCutoffs Json?
  problemScores Json?
  isPrivate Boolean @default(false)
  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
}

model UserVirtualContest {
  id Int @id @default(autoincrement())
  userId Int
  contestId Int
  startedAt DateTime
  endedAt DateTime
  score Float
  perProblemScores Json?
  userContextData Json?
  submissions VirtualSubmission[]
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
  @@unique([userId, contestId])
}

model VirtualSubmission {
  id Int @id @default(autoincrement())
  virtualContestId Int?
  activeVirtualContestUserId Int?
  contestProblemId Int
  time DateTime
  score Float
  subtaskScores Json
  contest UserVirtualContest? @relation(fields: [virtualContestId], references: [id], onDelete: Cascade)
  activeContest ActiveVirtualContest? @relation(fields: [activeVirtualContestUserId], references: [userId], onDelete: Cascade)
  problem ContestProblem @relation(fields: [contestProblemId], references: [id], onDelete: Cascade)
}

// is not FK'd to UserVirtualContest which is an array of completed contests
model ActiveVirtualContest {
  userId Int @id
  contestId Int
  startedAt DateTime @default(now())
  endedAt DateTime?
  autosynced Boolean @default(false)  
  score Float?
  perProblemScores Json?
  submissions VirtualSubmission[]
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  contest Contest @relation(fields: [contestId], references: [id], onDelete: Cascade)
}

model ScraperAuthToken {
  platform String @id
  token String
}

model OAuthState {
  id String @id
  userId Int?
  redirectUri String?
  createdAt DateTime @default(now())
}

model Follow {
  followerId Int
  followedId Int
  createdAt DateTime @default(now())
  follower User @relation("UserFollows", fields: [followerId], references: [id], onDelete: Cascade)
  followed User @relation("UserFollowedBy", fields: [followedId], references: [id], onDelete: Cascade)
  @@id([followerId, followedId])
}